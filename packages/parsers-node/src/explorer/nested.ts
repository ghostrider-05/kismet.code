// Generated by https://quicktype.io
//
// To change quicktype's target language, run command:
//
//   "Set quicktype target language"

import { getSuperClasses, RawUnrealJsonFile } from '../classes/index.js'

export interface Classes {
    name:              string;
    Class:             string;
    Extends:           string;
    structures:        Structure[];
    Package:           Package;
    placeable:         boolean;
    enums:             { [key: string]: string[] };
    variables:         Variable[];
    defaultproperties: Defaultproperty[];
    archetype:         string;
}

export enum Package {
    AkAudio = "AkAudio",
    Core = "Core",
    Engine = "Engine",
    GFxUI = "GFxUI",
    IPDrv = "IpDrv",
    OnlineSubsystemEOS = "OnlineSubsystemEOS",
    OnlineSubsystemSteamworks = "OnlineSubsystemSteamworks",
    ProjectX = "ProjectX",
    TAGame = "TAGame",
    WinDrv = "WinDrv",
}

export interface Defaultproperty {
    name:   string;
    value?: string;
}

export interface Structure {
    name:       string;
    properties: Variable[];
}

export interface Variable {
    flags:      string;
    name:       string;
    type:       string;
    replicated: Replicated;
    category:   null | string;
}

export enum Replicated {
    False = "False",
    True = "True",
}

// ------------------------------

export interface RecursiveTreeItem extends Variable {
    Package: Package;
    Class: string;
    archetype: string;
}

export interface RecursiveTreeItemReference {
    r: string;
}

export interface RecursiveTreeClassReference {
    cr: string;
    name: string;
}

export type RecursiveTree = Pick<RecursiveTreeItem, 'name'> & {
    c: ((RecursiveTree) | RecursiveTreeItem | RecursiveTreeClassReference)[]
}

export type RecursiveTreeReferences = Record<string, RecursiveTreeItem>

// function getFromReference (r: RecursiveTreeItemReference, variables: RecursiveTreeReferences): RecursiveTreeItem {
//     const item = Object.keys(variables).find(key => {
//         const v = variables[<never>key];
//         return `${v.Package}.${v.Class}.${v.name}.${v.type}` === r.r
//     })

//     return variables[item!]
// }

// function toItem (input: RecursiveTreeItem | RecursiveTreeItemReference, variables: RecursiveTreeReferences): RecursiveTreeItem {
//     return 'r' in input ? getFromReference(input, variables) : input
// }

function isClassItem (node: RecursiveTreeItem, nodes: Classes[]): boolean {
    return nodes.some(x => x.Class === node.type)
}

function getSuper (name: string, nodes: Classes[]) {
    return getSuperClasses(name, nodes as unknown as RawUnrealJsonFile[])
        .map(itemName => {
            const node = nodes.find(x => x.name === itemName)
            // if (!node) throw new Error('Unable to find node with name: ' + itemName)

            return node
        }).filter((n): n is NonNullable<typeof n> => n != undefined)
}

class RecursiveTreeClass {
    public variables: RecursiveTreeReferences = {};
    private keys: string[] = [];
    public classes: (RecursiveTreeItem & RecursiveTree)[] = []

    public get (ref: RecursiveTreeClassReference): RecursiveTree {
        return this.classes.find(x => x.type === ref.cr)!;
    }

    public add (tree: RecursiveTree & RecursiveTreeItem): boolean {
        if (!this.classes.some(n => n.type === tree.type)) {
            this.classes.push(tree)
            return true
        } else return false
    }

    public check (node: RecursiveTreeItem, nodes: Classes[], max: number): RecursiveTreeItem | RecursiveTreeClassReference {
        if (!isClassItem(node, nodes) || max === 0) return node;
        const children = getSuper(node.type, nodes);
    
        const items = this.convertToItems(children);

        const output = {
            ...node,
            c: items.map(item => this.check(item, nodes, max - 1))
        }

        this.add(output);

        return { cr: node.type, name: node.name }
    }

    public convertToItems (nodes: Classes[]) {
        const items: (RecursiveTreeItem)[] = nodes.flatMap(node => {
            return node.variables.map(v => {
                const { flags, ...variable } = v
                return {
                    ...variable,
                    Package: node.Package,
                    Class: node.Class,
                    // archetype: node.archetype
                } as RecursiveTreeItem
            })
        })
    
        return items
    }
}

export function createRecursiveTree (nodes: Classes[], options: { className: string; max: number }): RecursiveTree & { classes: RecursiveTree[]; } {
    const base = getSuper(options.className, nodes);
    const tree = new RecursiveTreeClass();

    const out = {
        name: options.className,
        c: tree.convertToItems(base).map(i => tree.check(i, nodes, options.max - 1)),
    }

    return {
        ...out,
        classes: tree.classes
    }
}